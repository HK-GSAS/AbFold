import argparse
import os
import time

import numpy
import numpy as np
import torch

from abfold.config import config
from abfold.data.data_process import process_repr, process_fasta, get_frames_from_pdb, load_mask_for_coord
from abfold.model import AbFold
from abfold.np import protein
from abfold.np.residue_constants import str_sequence_to_aatype
from abfold.utils.tensor_utils import tensor_tree_map
from train_ema import tensor_dict_to_device


def main(args):
    device = "cuda:1" if torch.cuda.is_available() else "cpu"
    model = AbFold(config)
    checkpoint_name = args.checkpoint_name
    if os.path.isfile(checkpoint_name):
        checkpoint = torch.load(checkpoint_name)
        if checkpoint_name == 'checkpoint_supervise':
            model.load_state_dict(checkpoint['model'])
        else:
            model.load_state_dict(checkpoint['student'])
    else:
        print("=> no checkpoint found")
    model.eval()
    model = model.to(device)
    repr_dir = args.repr_dir
    fasta_dir = args.fasta_dir
    output_dir = args.output_dir

    for line in os.listdir(repr_dir):
        repr_id = line.split('.')[0]
        repr_path = os.path.join(repr_dir, f'{repr_id}.pkl')
        fasta_path = os.path.join(fasta_dir, f'{repr_id}.fasta')
        point_feat_path = os.path.join(args.point_feat_dir, f'{repr_id}.pt')
        pdb_path = os.path.join(output_dir, f'{repr_id}_pred.pdb')

        seq_h, seq_l = process_fasta(fasta_path)
        s_h, s_l, z = process_repr(repr_path, seq_h)
        z_h, z_l = z.split([s_h.shape[-2], s_l.shape[-2]], -3)
        z_hh, z_hl = z_h.split([s_h.shape[-2], s_l.shape[-2]], -2)
        z_lh, z_ll = z_l.split([s_h.shape[-2], s_l.shape[-2]], -2)
        aatype_h = torch.tensor(str_sequence_to_aatype(seq_h))
        aatype_l = torch.tensor(str_sequence_to_aatype(seq_l))
        point_feat = torch.load(point_feat_path, map_location=torch.device('cpu')).squeeze()
        if len(seq_h) + len(seq_l) != point_feat.shape[0]:
            point_feat = point_feat[:len(seq_h) + len(seq_l)]

        feature = {'s_h': s_h, 's_l': s_l, 'z_hh': z_hh, 'z_hl': z_hl,
                   'z_lh': z_lh, 'z_ll': z_ll, 'aatype_h': aatype_h,
                   'aatype_l': aatype_l, 'point_feat': point_feat}

        feature = tensor_tree_map(lambda x: x.unsqueeze(dim=0), feature)
        feature = tensor_dict_to_device(feature, device)
        with torch.no_grad():
            result = model(feature)
        result = tensor_tree_map(lambda x: x.squeeze(dim=0), result)
        feature, result = tensor_dict_to_device(feature, 'cpu'), tensor_dict_to_device(result, 'cpu')
        time.sleep(1)
        feature['aatype'] = torch.cat([aatype_h, aatype_l], -1).numpy()
        feature['asym_id'] = np.concatenate([np.ones([len(seq_h)], numpy.int8) - 1,
                                             np.ones([len(seq_l)], numpy.int8)], -1)
        feature['residue_index'] = torch.cat([torch.arange(0, feature['aatype_h'].shape[-1]),
                                              torch.arange(0, feature['aatype_l'].shape[-1])], dim=-1).numpy()

        unrelaxed_protein = protein.from_prediction(feature, result)
        pdb_str = protein.to_pdb(unrelaxed_protein)
        with open(pdb_path, 'w') as fp:
            fp.write(pdb_str)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("--repr_dir", type=str, default="data/abfold/test/repr",
                        help="Directory containing precomputed representations")
    parser.add_argument("--fasta_dir", type=str, default="data/abfold/test/fasta",
                        help="Directory containing fasta files")
    parser.add_argument("--output_dir", type=str, default="data/abfold/test/pred_structures",
                        help="Directory in which to output predicted structures")
    parser.add_argument("--checkpoint_name", type=str, default="checkpoint_ema")
    parser.add_argument("--point_feat_dir", type=str, default="data/abfold/test/embed",
                        help="Directory containing embedding files generated by point_mae")
    args = parser.parse_args()
    main(args)
